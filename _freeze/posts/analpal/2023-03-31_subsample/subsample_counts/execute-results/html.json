{
  "hash": "e8ddb8532eb68c76de32bddd9edcfa70",
  "result": {
    "markdown": "---\ntitle: Using count data with the subsample() function of the divDyn package.\nresource-path: ['../../../']\nbibliography: 'bibliography/evolved.bib'\n#title-block-banner: '../../../images/ocean_sea_water_seascape_nature_3840x2160.jpg' \nauthor:\n  - name: Kocsis, Adam \n    url: \"../../../adam_kocsis.html\" \ntoc: true\ncategories: \n- subsampling\n- diversity\nlisting:\n  id: \"resources\"\n  template: ../../../templates/resources.ejs\n  contents: \n  - ../../../data/resources.yml\n  include:\n    title: \"{R,divDyn,pbdb,iNEXT}*\" \n---\n\n\n::: {#resources}\n:::\n\n\n\n\n\nAlthough the ``subsample()`` function was developed for estimating turnover rates and diversity changes over multiple time intervals, it was adapted to execute subsampling on single samples.\n\n\nLet's say that we have a sample of 20 species, where species have the following number of specimens:\n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\n# counts of specimens\ncounts <- c(35,19,13,9,6,4,2,2,2,2,2,2,2,1,1,1,1,1,1,1)\n```\n:::\n\n\n### Preparing data\n\nThe current version of divDyn [@kocsis2019package] can only accept extended formats for ecological samples. This means that every specimen (identity) has to be present as a separate object. To make the count data above compatible with ``subsample()``, we can use the ``rep()`` funciton from the base package to repeat placeholders (i.e. letters) that symbolize the specimens that belong to different species. \n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\n# one letter that represents each species\nspecies <- letters[1:length(counts)]\n\n# extended format of the sample\nspecimens <- rep(species, counts)\n```\n:::\n\n\nRunning the ``table()`` function confirms that the structure we created is indeed matching the count data above. \n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\ntable(specimens)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspecimens\n a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t \n35 19 13  9  6  4  2  2  2  2  2  2  2  1  1  1  1  1  1  1 \n```\n:::\n:::\n\n\nTo make the vector of specimens compatible with the ``subsample()`` function, we have to make it a ``data.frame``.\n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\nsamp <- data.frame(specimens, stringsAsFactors=FALSE)\n```\n:::\n\n\nAs factors are more difficult to work with (unless you intentionally want to), it is easier to write more reliable analyses if you stick with characters.\n\n### Richness function\n\nBy default, the ``subsample()`` function uses the ``divDyn()`` function as the applied procedure in the subsampling loops. We have to override this by another function that calculates diversity (e.g. richness) estimates from the long format of the sample. For richness, it is easiest to write your own function that just counts the number of unique elements in the vector.\n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\nrichness <- function(x) length(unique(x))\nrichness(specimens)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n\n### Subsampling\n\nThe important thing to note is, that the argument of this function has to be ``x``. In simple cases where the ``data.frame`` which is fed to the ``subsample`` function has only one column, this represents a vector of specimens.\n\nNow, all that remains is to feed our data to the subsampling. By default, subsample will execute classical rarefaction [@sanders_marine_1968]. \n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\n# Richness subsampled to 10 individuals, number of iterations is 1000\nsubsample(samp, tax=\"specimens\", q=10, FUN=richness, iter=1000, counter=F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.879\n```\n:::\n:::\n\n\nAs the target quota is quite low, you need to increase the number of iterations to make the estimate stabilize.\n\nTo run Shareholder Quorum Subsampling [@alroy_shifting_2010], you have to specify the ``type`` and the ``q`` arguments appropriately.\n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\n# Richness subsampled to 10 individuals, number of iterations is 1000\nsubsample(samp, tax=\"specimens\", q=0.5, type=\"sqs\", FUN=richness, iter=1000, counter=F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.455\n```\n:::\n:::\n\n\nYou can contrast this with the analytical solution (coverage-based rarefaction) [@chao_coverage-based_2012]  implemented in the iNEXT-package\n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\n# download with install.packages(iNEXT)\nlibrary(iNEXT)\n\n# estimate Hill numbers for 0.5 coverage\nestimateD(counts, base=\"coverage\", level=0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Assemblage        m      Method Order.q        SC       qD   qD.LCL   qD.UCL\n1       data 5.044756 Rarefaction       0 0.4999992 3.767626 2.730768 4.804484\n2       data 5.044756 Rarefaction       1 0.4999992 3.428733 2.514319 4.343146\n3       data 5.044756 Rarefaction       2 0.4999992 3.060668 2.276833 3.844502\n```\n:::\n:::\n\n\nValue we are interested in is ``qD`` at the order of ``0``, which is somewhat higher than the solution suggested by SQS, but the offset is really not high, concerning that we are talking about fractions of species. The true advantage of using ``subsample()`` is that you can supply any function as ``FUN`` and do not have to stick with Hill-numbers.\n\n### Ackowledgements\n\nThanks to Erin Saupe for asking about the example and indirectly to Seth Finnegan for his original course material.\n\n\n",
    "supporting": [
      "subsample_counts_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}